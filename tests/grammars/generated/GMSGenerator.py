# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class GMSGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def program(self, parent=None):
        with RuleContext(self, UnparserRule(name='program', parent=parent)) as current:
            self.statement_list(parent=current)
            self.EOF(parent=current)
            return current
    program.min_depth = 3

    def expr(self, parent=None):
        with RuleContext(self, UnparserRule(name='expr', parent=parent)) as current:
            self.term(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.PLUS, self.MINUS][choice0](parent=current)
                    self.term(parent=current)
            return current
    expr.min_depth = 3

    def term(self, parent=None):
        with RuleContext(self, UnparserRule(name='term', parent=parent)) as current:
            self.factor(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.STAR, self.SLASH][choice0](parent=current)
                    self.factor(parent=current)
            return current
    term.min_depth = 2

    def factor(self, parent=None):
        with RuleContext(self, UnparserRule(name='factor', parent=parent)) as current:
            with AlternationContext(self, [1, 4, 2, 1], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.NUMBER(parent=current)
                elif choice0 == 1:
                    self.LPAR(parent=current)
                    self.expr(parent=current)
                    self.RPAR(parent=current)
                elif choice0 == 2:
                    with AlternationContext(self, [1, 1], [1, 1]) as weights1:
                        choice1 = self._model.choice(current, 1, weights1)
                        [self.PLUS, self.MINUS][choice1](parent=current)
                    self.factor(parent=current)
                elif choice0 == 3:
                    self.NAME(parent=current)
            return current
    factor.min_depth = 1

    def statement_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='statement_list', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.statement(parent=current)
            return current
    statement_list.min_depth = 2

    def statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='statement', parent=parent)) as current:
            with AlternationContext(self, [5, 4, 2, 5, 1], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.assignment, self.compound_statement, self.declaration, self.print_statement, self.empty][choice0](parent=current)
            return current
    statement.min_depth = 1

    def assignment(self, parent=None):
        with RuleContext(self, UnparserRule(name='assignment', parent=parent)) as current:
            self.NAME(parent=current)
            self.EQUAL(parent=current)
            self.expr(parent=current)
            self.SEMI(parent=current)
            return current
    assignment.min_depth = 4

    def compound_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='compound_statement', parent=parent)) as current:
            self.LBRACE(parent=current)
            self.statement_list(parent=current)
            self.RBRACE(parent=current)
            return current
    compound_statement.min_depth = 3

    def declaration(self, parent=None):
        with RuleContext(self, UnparserRule(name='declaration', parent=parent)) as current:
            self.TYPE(parent=current)
            self.WS(parent=current)
            self.NAME(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.COMMA(parent=current)
                    self.NAME(parent=current)
            self.SEMI(parent=current)
            return current
    declaration.min_depth = 1

    def print_statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='print_statement', parent=parent)) as current:
            self.PRINT(parent=current)
            self.WS(parent=current)
            self.expr(parent=current)
            self.SEMI(parent=current)
            return current
    print_statement.min_depth = 4

    def empty(self, parent=None):
        with RuleContext(self, UnparserRule(name='empty', parent=parent)) as current:
            pass
            return current
    empty.min_depth = 0

    def PRINT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='PRINT', parent=parent)) as current:
            UnlexerRule(src='print', parent=current)
            return current
    PRINT.min_depth = 0

    def TYPE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='TYPE', parent=parent)) as current:
            UnlexerRule(src='Num', parent=current)
            return current
    TYPE.min_depth = 0

    def EQUAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EQUAL', parent=parent)) as current:
            UnlexerRule(src='=', parent=current)
            return current
    EQUAL.min_depth = 0

    def PLUS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='PLUS', parent=parent)) as current:
            UnlexerRule(src='+', parent=current)
            return current
    PLUS.min_depth = 0

    def MINUS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='MINUS', parent=parent)) as current:
            UnlexerRule(src='-', parent=current)
            return current
    MINUS.min_depth = 0

    def STAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='STAR', parent=parent)) as current:
            UnlexerRule(src='*', parent=current)
            return current
    STAR.min_depth = 0

    def SLASH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SLASH', parent=parent)) as current:
            UnlexerRule(src='/', parent=current)
            return current
    SLASH.min_depth = 0

    def LPAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LPAR', parent=parent)) as current:
            UnlexerRule(src='(', parent=current)
            return current
    LPAR.min_depth = 0

    def RPAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RPAR', parent=parent)) as current:
            UnlexerRule(src=')', parent=current)
            return current
    RPAR.min_depth = 0

    def LBRACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LBRACE', parent=parent)) as current:
            UnlexerRule(src='{', parent=current)
            return current
    LBRACE.min_depth = 0

    def RBRACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RBRACE', parent=parent)) as current:
            UnlexerRule(src='}', parent=current)
            return current
    RBRACE.min_depth = 0

    def SEMI(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SEMI', parent=parent)) as current:
            UnlexerRule(src=';', parent=current)
            return current
    SEMI.min_depth = 0

    def COMMA(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COMMA', parent=parent)) as current:
            UnlexerRule(src=',', parent=current)
            return current
    COMMA.min_depth = 0

    def NUMBER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NUMBER', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            return current
    NUMBER.min_depth = 0

    def NAME(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NAME', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[3]), parent=current)
            return current
    NAME.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[4]), parent=current)
            return current
    WS.min_depth = 0

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(48, 58)])),
        2: list(itertools.chain.from_iterable([range(65, 91), range(95, 96), range(97, 123)])),
        3: list(itertools.chain.from_iterable([range(48, 58), range(65, 91), range(95, 96), range(97, 123)])),
        4: list(itertools.chain.from_iterable([range(32, 33)])),
    }
